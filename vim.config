"ln -sf ${PWD}/vim_config  ${HOME}/.vimrc
"NOTE : alias for ctrl = c,ctrl,C alias for enter = cr	
"Minimum settings maximum coding
"omni settings
:set number 
:set hlsearch
:set incsearch 
:set history=1000
:set ruler 	
:set undolevels=1000	

"set search with lighBlue
hi Search ctermbg=LightBlue

" Moved all tabs and spaces to ftplugins 
":set backspace=2 
":set tabstop=8
":set expandtab
":set shiftwidth=4
":set softtabstop=4

"make backspace work like most other apps
:syn on	

"Replace esc support with jk 	
:inoremap jk <esc>	

"Forcefull turnoff
:so ${HOME}/.vim/vim.addons/hard.reset.vim



"Fast window resizing with +/- keys (horizontal); / and * keys (vertical)	
if bufwinnr(1) 	
map + <C-W>+	
map - <C-W>-	
map < <c-w><	
map > <c-w>>	
endif 	

"Allow fast switching between window	
:map <C-H> <C-W>h 	
:map <C-L> <C-W>l 	

" Only do this part when compiled with support for autocommands
if has("autocmd")
    "set no
    set nocompatible
    " Enable file type detection
    filetype on
    " Syntax of these languages is fussy over tabs Vs spaces

    "automatic sourcing after saving the file
    autocmd bufwritepost .vimrc source $MYVIMRC

    "autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
    "autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab

    " Customisations based on house-style (arbitrary)
    "autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
    "autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
    "autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab

    " Treat .rss files as XML
    autocmd BufNewFile,BufRead *.rss setfiletype xml
    au BufNewFile,BufRead *.handlebars setfiletype html

    "Redo use <ctrl-r>	
    "autocmd BufRead *.py set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class
endif

    "surround plugin surround_45 : ASCII= _
    autocmd FileType php let b:surround_45 = "<?php \r ?>"

    autocmd FileType html let b:surround_45 = "<html> \r </html>"
"Indentation
vnoremap < <gv
vnoremap > >gv


"Add pathogen
filetype off " Pathogen needs to run before plugin indent on
execute pathogen#infect()
call pathogen#helptags() " generate helptags for everything in 'runtimepath'
filetype plugin indent on
syntax on

" Solarized

:so ${HOME}/.vim/vim.addons/solarized.color.vim

"Spell check macro
"Use of abbrevation 
":iabbrev teh the
":iabbrev Lunix Linux
":syntax keyword WordError teh Lunix 

"Edit text in vim
":set tw=0 wrap linebreak


"Use of vim macro
map _cl:call CleanLint()<CR>
func CleanLint()
    g/gtk_x11.c:*enum/d
    g/if_perl.*conversion to .*proto/d
endfunc 

"File Naviagation ctrlp plugin 	
":set runtimepath^=~/dotconfig/.vim/bundle/ctrlp.vim 	

:set wildignore+=*.so,*.swp,*.zip,*.pyc,*.class	

let g:ctrlp_show_hidden = 1	
let g:ctrlp_max_height = 30	

set omnifunc=syntaxcomplete#Complete 	

"tab complete 	
"http://stackoverflow.com/questions/2170023/how-to-map-keys-for-popup-menu-in-vim	
function! OmniPopup(action)	
if pumvisible()	
 if a:action == 'j'	
      return "\<C-N>"	
      elseif a:action == 'k'	
      return "\<C-P>"	
      endif	
    endif	
 return a:action	
endfunction	
inoremap <silent><C-j> <C-R>=OmniPopup('j')<CR>	
inoremap <silent><C-k> <C-R>=OmniPopup('k')<CR>	

"shortcut to open NERDTREE	
map <C-d> :NERDTreeToggle<CR>	


"shortcut for TlistOpen
map <C-l> :TlistOpen<cr>
map <C-k> :TlistToggle<cr>
nmap gd <C-]> 
nmap gb <C-t> 
"move forward and back through matching tags
"map <c-b> :tprevious<CR>
"map <c-n> :tnext<CR>

"CTRL-p plugin

"To disable
"let g:loaded_ctrlp = 1

"Tabularize to align the json 

"let mapleader=','
"if exists(":Tabularize")
"    nmap <Leader>t= :Tabularize /=<CR>
"    vmap <Leader>o= :Tabularize /=<CR>
"    nmap <Leader>o: :Tabularize /:\zs<CR>
"    vmap <Leader>o: :Tabularize /:\zs<CR>
"endif


"https://gist.github.com/tpope/287147
"If you put this in your vimrc file, then it will call the :Tabularize command each time you insert a | character.
inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
 
function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction

"color scheme

"neocomplete


"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  "return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType cml,oml,fxml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

"quick traverse in vim list
"Refer Tim Popeâ€™s unimpaired.vim plugin

nnoremap <silent> [b :bprevious <CR> 
nnoremap <silent> ]b :bnext <CR> 
nnoremap <silent> [B :bfirst <CR> 
nnoremap <silent> ]B :blast <CR>


"Reload the ctags
nnoremap <f5> :!ctags -R <CR>

"tags =./tags,tags

noremap <C-a> :CtrlP ~/code/applogic/web/FinancialInstrument/BuyerCredit/Application<CR>


"cscope init : cscope -RUbq
if has("cscope")
    set csprg=/usr/bin/cscope
    set csto=0
    set cst
    set csverb
    " C symbol
    nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
    " definition
    nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>
    " functions that called by this function
    nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>
    " funtions that calling this function
    nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>
    " test string
    nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>
    " egrep pattern
    nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>
    " file
    nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
    " files #including this file
    nmap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>

    " Automatically make cscope connections
    function! LoadCscope()
        let db = findfile("cscope.out", ".;")
        if (!empty(db))
            let path = strpart(db, 0, match(db, "/cscope.out$"))
            set nocscopeverbose " suppress 'duplicate connection' error
            exe "cs add " . db . " " . path
            set cscopeverbose
        endif
    endfunction
    au BufEnter /* call LoadCscope()

endif

" ctags
" horizontal and vertical split with alt + [
map <A-[> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>



"open the .h and .cpp files if one of the file is open use ,o
function! OpenOther()
    if expand("%:e") == "cpp"
        exe "vsplit" fnameescape(expand("%:p:r:s?src?include?").".h")
    elseif expand("%:e") == "h"
        exe "vsplit" fnameescape(expand("%:p:r:s?include?src?").".cpp")
    endif
endfunction

nmap ,o :call OpenOther()<CR>



":mksession! <file_name>
"vim -S <file_name>
"navigate in buffer
nnoremap <silent> [b :bprevious <CR>
nnoremap <silent> ]b :bnext <CR> 
nnoremap <silent> [B :bfirst <CR> 
nnoremap <silent> ]B :blast <CR>


"session 

function! MakeSession()
  let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
  if (filewritable(b:sessiondir) != 2)
    exe 'silent !mkdir -p ' b:sessiondir
    redraw!
  endif
  let b:filename = b:sessiondir . '/session.vim'
  exe "mksession! " . b:filename
endfunction

function! LoadSession()
  let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
  let b:sessionfile = b:sessiondir . "/session.vim"
  if (filereadable(b:sessionfile))
    exe 'source ' b:sessionfile
  else
    echo "No session loaded."
  endif
endfunction

" Updates a session, BUT ONLY IF IT ALREADY EXISTS
function! UpdateSession()
  let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
  let b:sessionfile = b:sessiondir . "/session.vim"
  if (filereadable(b:sessionfile))
    exe "mksession! " . b:sessionfile
    echo "updating session"
  endif
endfunction

"au VimEnter * nested :call LoadSession()

map ,l :call LoadSession()<CR>
"au VimLeave * :call MakeSession()
map ,c :call MakeSession()<CR>
map ,u :call UpdateSession()<CR>

